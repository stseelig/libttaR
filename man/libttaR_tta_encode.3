.\" t
.\"     Title: libttaR_tta_encode
.\"    Author: Shane Seelig
.\"      Date: 2025-12-30
.\"    Source: libttaR 2.1.1
.\"  Language: English
.\"
.\" ##########################################################################

.TH "LIBTTAr_TTA_ENCODE" "3" "2025\-12\-30" "libttaR 2.1.1" \
"LibTTAr Programmer's Manual"

.\" ##########################################################################

.SH "NAME"
libttaR_tta_encode, libttaR_tta_decode \- a reentrant TTA codec

.\" ##########################################################################

.SH "SYNOPSIS"

.nf
.B #include <libttaR.h>

.BI "enum LibTTAr_EncRetVal libttaR_tta_encode("
.RS 8
.BI "uint8_t *restrict " dest ",
.BI "const int32_t *restrict " src ",
.BI "struct LibTTAr_CodecState_Priv *restrict " priv ",
.BI "struct LibTTAr_CodecState_User *restrict " user ",
.BI "const struct LibTTAr_EncMisc *restrict " misc "
.RE
.BI ");"

.BI "enum LibTTAr_DecRetVal libttaR_tta_decode("
.RS 8
.BI "int32_t *restrict " dest ",
.BI "const uint8_t *restrict " src ",
.BI "struct LibTTAr_CodecState_Priv *restrict " priv ",
.BI "struct LibTTAr_CodecState_User *restrict " user ",
.BI "const struct LibTTAr_EncMisc *restrict " misc "
.RE
.BI ");"
.fi

.\" ##########################################################################

.SH "DESCRIPTION"

.BR libttaR_tta_encode (3)
encodes a whole or partial TTA frame.

.BR libttaR_tta_decode (3)
decodes a whole or partial TTA frame.

.\" -------------------------------------------------------------------------#

.SS Arguments

*\fIdest\fR
.RS 8
The destination buffer.
Needs to be padded with at least
\fBlibttaR_ttabuf_safety_margin\fR(3)
bytes when encoding.
.RE

*\fIsrc\fR
.RS 8
The source buffer.
Needs to be padded with at least
\fBlibttaR_ttabuf_safety_margin\fR(3)
bytes when decoding.
.RE

*\fIpriv\fR
.RS 8
The codec's private state.
The struct is opaque and needs to be allocated and properly aligned
(\fBLIBTTAr_CODECSTATE_PRIV_ALIGN\fR)
with the size from
.BR libttaR_codecstate_priv_size (3).
.RE

*\fIuser\fR
.RS 8
The codec's user readable state.
Must be initialized with
.B LIBTTAr_CODECSTATE_USER_INIT
before the first call for a new frame.

.nf
\fBstruct LibTTAr_CodecState_User\fR {
    uint32_t    ncalls_codec;
    uint32_t    crc;
    size_t      ni32;
    size_t      ni32_total;
    size_t      nbytes_tta;
    size_t      nbytes_tta_total;
};
.fi

ncalls_codec:
.RS 8
The number of successful calls to the codec function.
.RE

crc:
.RS 8
The frame CRC.
.RE

ni32:
.RS 8
The number of int32_t PCM read/written for the last call.
.RE

ni32_total:
.RS 8
The total number of int32_t PCM read/written across all calls
for the current frame.
.RE

nbytes_tta:
.RS 8
The number of TTA bytes written/read for the last call.
.RE

nbytes_tta_total:
.RS 8
The total number of TTA bytes written/read across all calls
for the current frame.
.RE

.RE

*\fImisc\fR
.RS 8
Other values/properties.

.nf
\fBstruct LibTTAr_EncMisc\fR {
    size_t                      dest_len;
    size_t                      src_len;
    size_t                      ni32_target;
    size_t                      ni32_perframe;
    enum LibTTAr_SampleBytes    samplebytes;
    unsigned int                nchan;
};

\fBstruct LibTTAr_DecMisc\fR {
    size_t                      dest_len;
    size_t                      src_len;
    size_t                      ni32_target;
    size_t                      nbytes_tta_target;
    size_t                      ni32_perframe;
    size_t                      nbytes_tta_perframe;
    enum LibTTAr_SampleBytes    samplebytes;
    unsigned int                nchan;
};
.fi

dest_len:
.RS 8
The length of the destination buffer.
.RE

src_len:
.RS 8
The length of the source buffer.
.RE

ni32_target:
.RS 8
The target number of int32_t PCM from the src/dest buffer to encode/decode.
Must be evenly divisible by \fImisc\fR->nchan.
.RE

nbytes_tta_target:
.RS 8
The target number of TTA bytes from the dest/src buffer to encode/decode.
.RE

ni32_perframe:
.RS 8
The number of uncoded int32_t per TTA frame.
See
.BR libttaR_nsamples_perframe_tta1 (3).
.RE

nbytes_tta_perframe:
.RS 8
The number of encoded bytes in the current TTA frame.
.RE

samplebytes:
.RS 8
The number of bytes per samples in the originally sized PCM.

.nf
\fBenum LibTTAr_SampleBytes\fR {
    LIBTTAr_SAMPLEBYTES_1   = 1u,
    LIBTTAr_SAMPLEBYTES_2   = 2u,
    LIBTTAr_SAMPLEBYTES_3   = 3u
};
.fi
.RE

nchan:
.RS 8
The number of audio channels in the PCM.
.RE

.\" -------------------------------------------------------------------------#

.SS Warning
*\fIpriv\fR, *\fIuser\fR, \fImisc\fR->nchan, \fImisc\fR->ni32_perframe, and
\fImisc\fR->nbytes_tta_perframe
should not be modified between consecutive calls for the same frame,
unless you know what you are doing.

.\" ##########################################################################

.SH "RETURN VALUE"

.nf
\fBenum LibTTAr_EncRetVal\fR {
    LIBTTAr_ERV_OK_DONE         = /* =0 */,
    LIBTTAr_ERV_OK_AGAIN        = /* >0 */,
    LIBTTAr_ERV_FAIL_OVERFLOW   = /* >0 */,
    LIBTTAr_ERV_INVAL_RANGE     = /* <0 */,
    LIBTTAr_ERV_INVAL_TRUNC     = /* <0 */,
    LIBTTAr_ERV_INVAL_BOUNDS    = /* <0 */,
    LIBTTAr_ERV_INVAL_ALIGN     = /* <0 */,
    LIBTTAr_ERV_MISCONFIG       = /* <0 */
};

\fBenum LibTTAr_DecRetVal\fR {
    LIBTTAr_DRV_OK_DONE         = /* =0 */,
    LIBTTAr_DRV_OK_AGAIN        = /* >0 */,
    LIBTTAr_DRV_FAIL_DECODE     = /* >0 */,
    LIBTTAr_DRV_FAIL_OVERFLOW   = /* >0 */,
    LIBTTAr_DRV_INVAL_RANGE     = /* <0 */,
    LIBTTAr_DRV_INVAL_TRUNC     = /* <0 */,
    LIBTTAr_DRV_INVAL_BOUNDS    = /* <0 */,
    LIBTTAr_DRV_INVAL_ALIGN     = /* <0 */,
    LIBTTAr_DRV_MISCONFIG       = /* <0 */
};
.fi

.\" -------------------------------------------------------------------------#

.SH Success

.RS 4

\fBLIBTTAr_ERV_OK_DONE\fR, \fBLIBTTAr_DRV_OK_DONE\fR
.RS 8
The frame finished coding.
.RE

\fBLIBTTAr_ERV_OK_AGAIN\fR, \fBLIBTTAr_DRV_OK_AGAIN\fR
.RS 8
The frame did not finish coding.
The buffers and \fImisc\fR values should be adjusted for another call.
.RE

.RE

.\" -------------------------------------------------------------------------#

.SH Failure

.RS

If one of the following is returned,
\fIuser\fR and \fIpriv\fR
are likely in a corrupted, unrecoverable state.

\fBLIBTTAr_DRV_FAIL_DECODE\fR
.RS 8
The frame finished decoding, but
(\fIuser\fR->nbytes_tta_total !\= \fImisc\fR->nbytes_tta_perframe), or
the frame did not finish decoding, but
(\fIuser\fR->nbytes_tta_total > \fImisc\fR->nbytes_tta_perframe).
This would be caused by either corrupted or malformed TTA data.

The absense of this value does not guarantee that the data was correctly
decoded, only that the "correct" number of bytes was read.
There is a check in the rice decoder to stop after reading so many bytes, but
it does not return an error, it just stops reading the current code and then
continues (for performance reasons).
It should be possible to construct an invalid TTA frame (with a good CRC) that
could get the decoder to read the "correct" number of bytes.
.RE

\fBLIBTTAr_ERV_FAIL_OVERFLOW\fR, \fBLIBTTAr_DRV_FAIL_OVERFLOW\fR
.RS 8
An integer value (\fIuser\fR size_t) overflowed.
It would probably be caused by improperly setting the parameters or state.
.RE

.RE

.\" -------------------------------------------------------------------------#

.SH Error (<0)

.RS 4

\fBLIBTTAr_ERV_INVAL_RANGE\fR, \fBLIBTTAr_DRV_INVAL_RANGE\fR
.RS 8
Some \fImisc\fR value is 0 or a bad enum value.
On a (likely) 32-bit system, this could be returned if
\fImisc\fR->nchan is too large.
(\fBlibttaR_ttabuf_safety_margin\fR(3) overflow)
.RE

\fBLIBTTAr_ERV_INVAL_TRUNC\fR, \fBLIBTTAr_DRV_INVAL_TRUNC\fR
.RS 8
The last sample is truncated.
(\fImisc\fR->ni32_target % \fImisc\fR->nchan != 0)
.RE

\fBLIBTTAr_ERV_INVAL_BOUNDS\fR, \fBLIBTTAr_DRV_INVAL_BOUNDS\fR
.RS 8
Some \fImisc\fR value would cause a bounds issue.
.RE

\fBLIBTTAr_ERV_INVAL_ALIGN\fR, \fBLIBTTAr_DRV_INVAL_ALIGN\fR
.RS 8
A pointer/buffer (\fIpriv\fR) is not properly aligned.
.RE

\fBLIBTTAr_ERV_MISCONFIG\fR, \fBLIBTTAr_DRV_MISCONFIG\fR
.RS 8
The library was misconfigured when built; see \fBlibttaR_test_nchan\fR(3).
.RE

The debug build of the library may abort instead of returning an error.

.RE

.\" ##########################################################################

.SH "ATTRIBUTES"

Both are MT-Safe.

.\" ##########################################################################

.SH "EXAMPLES"

.\" -------------------------------------------------------------------------#

Read the following functions in the library source code for usage examples.

.RS 4

libttaR/src/cli/modes/mode_encode_loop.c :: enc_frame_encode()

libttaR/src/cli/modes/mode_decode_loop.c :: dec_frame_decode()

.RE

.\" ##########################################################################

.SH "SEE ALSO"

.BR libttaR_pcm_read (3),
.BR libttaR_pcm_write (3),
.BR libttaR_crc32 (3),
.BR libttaR_misc (3)

.\" ##########################################################################

.SH "AUTHOR"

.B "Shane Seelig"
.RS 4
Developer
.RE

.\" EOF ######################################################################
